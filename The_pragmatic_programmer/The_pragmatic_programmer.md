### 注重实效的哲学


- 我的源码让猫给吃了
  
  提供各种选择，不要找蹩脚的借口。 不要怕犯错，承认它（人人都会犯错），也不要害怕寻求帮助。承担自己应该承担的责任。
  
- 软件的熵

  破窗理论：不要容忍破窗户。不要留着“破窗户”不修，如果没有足够的时间进行适当的修理，可以用注释，‘未实现’或者‘dummy data'。
  
- 石头汤与煮青蛙
	
  做变化的催化剂：人们发现，参与正在发生的成功要更容易。让他们瞥见未来，你就能让他们聚集在你周围。
  
  记住大图景： 持续不断地观察周围发生的事情，而不只是你自己在做的事情。

- 足够好的软件

  欲求更好，常把好事变糟。或曰: 过早优化是万恶之源。
  
  使质量成为需求问题，编程就像是绘画，你需要懂得何时止步。
  
- 你的知识资产

  知识上的投资总能得到最好的回报。投资你的知识资产，就想投资金融资产一样： 定期投资，多元化，管理风险，低买高卖，重新评估和平衡。 
  
  建议：每年至少学习一种新语言，每季度阅读一本技术书籍，也要阅读非技术书籍，上课，参加本地用户组织，试验不同的环境，跟上潮流，上网。
  
  持续投入非常重要。阅读，即使是碎片化阅读也是非常重要的。
  
  批判的思考你读到的和听到的。需要确保资产中的知识是准确的。
  
- 交流

  我相信，被打量总被被忽略要好。
  
  规划你想要说的东西，写出大纲。然后问你自己“这是否讲清了我要说的所有内容？”
  
  了解你的听众： 你想让他们学到什么？他们对你讲的什么感兴趣？他们有多富有经验？他们想要多少细节？你想要让谁拥有这些信息？你如何促使他们听你说话？
  
  选择时机：对于重要的谈话，选择合适的时机，有的时候，只需要简单地问一句“现在我们可以谈谈......吗？"
  
  选择风格
  
  让文档美观
  
  让听众参与
  
  做倾听者
  
  回复他人： 你说什么和你怎么说同样重要。

### 注重实效的途径

- 重复的危害
  
  强加的重复： 写清晰的代码可以减少注释
  
  无意的重复： computed property 例子
  
  无耐性的重复： 欲速则不达
  
  开发者之间的重复
  
  
- 正交性

  消除无关事物之间的影响： 解耦，又比如MVC，比如改一个功能，多少模块需要改变
   
  让代码保持解耦
   
  避免使用全局数据
   
  避免编写相似的函数
   
  测试： 做单元测试也可以发现正交性，比如做一个单元测试应当只需要这个模块本身。
  
- 可撤销性

  不存在最终决策
  
  预先考虑，比如支持多种版本，部署问题

- 曳光弹

  用曳光弹找到目标
  
  用户能够及早看到能工作的东西
  
  开发者构建了一个他们能在其中工作的结构
  
  你有了一个集成平台
  
  你有了可用于演示的东西
  
  你将更能能够感受到工作进展
  
  原型制作生成用过就扔的代码。曳光代码虽然简约，但却是完整的，并且构成了最终系统的骨架的一部分。原型制作视为在第一发曳光弹发射之前进行的侦察和情报收集工作。
  

- 原型与便签
 
  原型制作更便宜： 可以先用高级语言实现原型，推迟考虑细节，制作出能工作的代码
  
  制作原型时，我们可以忽略： 正确性，完整性，健壮性，风格。
  
- 领域语言
  
  语言的界限就是一个人世界的界限。
  
  计算机语言会影响你思考问题的方式，以及你看待交流的方式。
  
  靠近问题领域编程，实现小型语言（BNF），比如我们的配置文件
  
- 估算

  估算，以避免发生意外。
  
  我们使用不同精度的词语会导致我们完成工作在不同的时间内。
  
  '我等会儿回答你。'  放慢估算的速度可能会得到更好的结果
  
### 基本工具

- 纯文本的威力
  
  用纯文本保存知识。二进制难懂，但不代表更安全。你可以加密，md5来处理数据。
  
  保证不过时： 文本是 human readable / human understandable，能被理解的自描述的数据会存活更长久。（看历史也是这样）
  
  杠杆作用： 计算世界中的每一样工具，都能够在纯文本上进行操作。 Unix非常依赖面向行的纯文本文件。diff等工具也在纯文本上很酷的使用。
  
  更易于测试： 利用 Perl、Python非常容易测试纯文本。
  
  纯文本的优点比其所有的缺点都重要。
  
- Shell游戏
  
  GUI虽然很棒，但是无法使常见任务自动化，或者是利用工具的全部力量。
  
  找出修改日期比你的 Makefile 的修改日期更近的全部c文件 : find .-name'*.c' -newer Makefile -print
  
  构造我的源码的 zip/tar 存档文件： zip archive.zip *h *c 或 tar cvf archive tar *.h *.c
  
  在上周没有被修改过的 Java 文件： find .-name'*.java' -mtime +7 -print
  
  在上周没有被修改过的 Java 文件中，哪些使用了 awt 库： find .-name'*.java' -mtime +7 -print | xargs grep 'java.awt'
  
  利用 Shell Commands 的力量
  
  熟悉 Shell 提高自己的生产率
  
- 强力编辑

  用好一种跨平台的编辑器， Emacs， vim
  
  这种编辑器需要： 可配置，可扩展，可编程
  
- 源码控制

  进步远非由变化组成，而是取决于好记性，不能记住过去的人，被判重复过去。
  
  总是使用源码控制， 总是，即使你的团队只有你一个人，你的项目只需一周时间；即使是“用过就扔”的原型；即使工作对象并非源码。
  
  使用源码控制可以进行自动的和可重复的产品构建。
  
- 调试

  要修正问题，而不是发出指责。
  
  不要恐慌。尝试再现bug，使数据可视化，查看 stack trace， rubber duck debug...
  
  如果遇到令自己惊讶的bug，记录它，找出它为什么会发生。
  
  不要假定，要证明
  
- 文本操纵

  学习一种文本操纵语言
  
- 代码生成器

  编写能编写代码的代码 (Write Code That Writes Code)
  
  比如创建源文件，转换编程语言...(其实就是操纵文本)


### 注重实效的偏执

  你不可能写出完美的软件，注重实效的程序员脸自己也不信任。
  
- 按合约设计  
  
  与计算机系统打交道很苦难。与人打交道更困难。
  
  合约既规定你的权利与责任，也规定了对方的权利与责任。
  
  DBC： 这里的合约不仅仅是人与人之间的合约，也是代码应遵循的规则。 前条件，后条件，类不变项。
  
  Liskov替换原则： 子类必须要能通过基类的接口使用，而使用者无须知道其区别。
  
  断言： runtime不支持合约，使用断言。
  
  早崩溃：如果软件会崩溃，让它更早崩溃。
  
  语义不变项： 出错时要偏向消费者
  
- 死程序不说谎

  早崩溃，要崩溃，不要破坏。死程序带来的危害通常比有疾患的程序要小得多。
  
- 断言式编程

  如果它不可能发生，用断言确保它不会发生 assert
  
  传给断言的条件不应该有副作用，绝不要把必须执行的代码放入assert中，因为断言可能会在编译时被关闭
  
  不要用断言代替真正的错误处理。断言检查的是决不应该发生的事情。
  
- 何时使用异常

  移走所有的异常，代码应该依然能够运行。
  
  将异常用于异常问题。
  
- 怎样配平资源

  要有始有终
  
  嵌套的分配： 以与资源分配的次序相反的次序解除资源的分配。在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。
  
  无论是谁分配的资源，它都应该负责接触该资源的分配。
  

### 弯曲，或折断

- 解耦与德墨忒耳法则

  ‘羞怯’的工作方式：不向别人暴露你自己，不与太多人打交道
  
  代码模块化
  
  使模块之间的耦合减至最少
  
  
  
  

  