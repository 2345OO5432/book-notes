### Chapter 1 

- echo $? 检查C程序的退出状态

- 编译型语言 C  vs 解释型语言 Python

- 编译器 GNU Compiler Collection :  gcc 

- compile & run : 
  gcc file.c -o file 
  ./file
 
- compile & run together:
  gcc file.c -o file && ./file

- 在类Unix系统中，之所以要加 ./ 是因为运行程序必须制定其所在的目录，除非程序的目录已经列在了PATH环境变量中

- C语言不支持现成的字符串（再强调一次），以字符为元素的数组

- C语言中布尔值使用数字表示的，0表示假，任何不等于0则为真


### Chapter 2

- 指针就是存储器中某条数据的地址。指针避免副本和共享数据。

- 找出变量的存储器地址，用&运算符， printf("x保存在 %p\n", &x);

- 得到变量的地址： int *address_of_x = &x;  读取地址中的内容 int value_stored = *address_of_x; 改变地址中的内容：*address_of_x = 99; 
  &运算符：取地址， *接收地址，告诉地址中的数据，*对指针解引用。
  所谓指针变量，也就是地址变量。

- sizeof("Turtiles!") 返回 9，包含8个字符+ '\0'

- 数组变量好比指针，创建了一个数组，数组变量就可以当指针用。数组变量指向数组中第一个元素，如果把函数参数声明为数组，它会被当做指针处理。

- sizeof 是一个运算符，运算符就是一串指令；而函数会调到一段独立的代码

- 数组变量 vs 指针 
  sizeof 数组是数组的大小 char s[] = "How big is it?", sizeof(s) = 15
  char *t = s; sizeof(t) = 4 or 8.
  数组的地址是数组的地址： & s = s
  &t != t 表示的是变量t的地址
  数组变量不能指向其它地方，比如 s = t 会报编译错误。
  把数组赋值给指针，会丢失一些信息，所谓退化。

- scanf("%d", &i); scanf("%39s", name); scanf需要更新内容，所以需要使用指针取地址。
  我们需要限制scanf字符串长度，否则如果长度超过，我们会有segmentation fault 或者abort trap（这个trap是在kernal mode地方切换的trap么？）

- fgets
  char food[5];
  printf("Enter favorite food: ");
  fgets(food, sizeof(food), sstdin);  
  这里的sizeof 包括 '\0'的长度， scanf则需要长度-1
  如果food是一个指针，我们需要显式给出长度

- 修改只读字符串，出现bus error错误
  所以建议这样： const char *s = "some string";
  这样如果尝试修改报错。

- char cards[] 是一个数组，而且必须立即赋值，但是如果是函数参数 void stack_deck(char cards[]) 与 void stack_deck(char *cards) 等效

- 局部变量保存在栈上


### Chapter 2.5

- string.h  

- 数组的数组 和 指针的数组


### Chapter 3 

- 使用 < 重新定向标准输入，比如 ./geo2json < gpsdata.csv

- 使用 > 重新定向标准输出，比如 ./geo2json < gpsdata.csv > output.json

- printf("") = fprintf(stdout, "")

- ./secret_messages < secret.txt > message1.txt 2 > message2.txt 重定向标准输出 以及 2> 重定向标准错误

- pipe | 连接一个进程的标准输出与另一个进程的标准输入。例子 (./bermuda | ./geo2json) < spooky.csv > output.json

- 创建数据流，读取数据： FILE *in_file = fopen("input.txt", "r") 
  写数据 FILE *out_file = fopen("output.txt", "w");
  数据流创建完毕后，可以用fprintf往数据流中打印数据 fprintf(out_file, " xxxx ");
  用fscanf读取数据： fscanf(in_file, "%79[^\n]\n", sentence);
  关闭数据流 fclose(in_file); fclose(out_file);

- 安全检查
  FILE *in;
  if (!(in = fopen("我不存在.txt", "r"))){
    fprintf(stderr, "无法打开文件.\n");
    return 1;
  }

- ps -ae 显示所有进程，包括后台运行的进程。
  tail -f logfile.txt 持续显示文件末尾新添加的数据。

- unistd.h 不是标准库，是POSIX库

  rocket-to -e 4 -a Brasilia Tokyo London
  
  #include <unistd.h>
  
  while ((ch = getopt(argc, argv, "ae:")) != EOF) 
  switch(ch) { // 注意这里先有swtich，再有大括号
  ...
  case 'e':
   engine_count = optarg;  // 注意这里engine_count 会变成4
  ...  
  }
 
  argc -= optind;
  argv += optind;
  // 这两行作用是跳过已经读取的选项

- '--' 可以用来隔开参数和选项


### Chapter 4

- 整形 / 整形 = 舍入的整数

- limits.h 和 float.h 中能有： INT_MAX, INT_MIN, sizeof(int), FLT_MAX, FLT_MIN, sizeof(float)

- 预处理 / 编译 / 汇编 / 链接

- extern int password; 共享变量

- 多个文件编译： gcc file1.c file2.c -o file 

- 把源代码编译为目标文件 gcc -c *.c  
  把目标文件链接起来     gcc *.o -o launch
  唯一修改过的文件 gcc -c thruster.c  重新创建thruster.o文件  gcc *.o -o launch 重新链接所有目标文件

- make 工具: 依赖项 生成方法
  makefile or Makefile 
  
  launch.o: launch.c launch.h thruster.h
  	gcc -c launch.c
  thruster.o: thruster.h thruster.c
  	gcc -c thruster.c
  launch: launch.o thruster.o
   	gcc launch.o thruster.o -o launch
  生成方法是tab

- autoconf 可以生成makefile

  







