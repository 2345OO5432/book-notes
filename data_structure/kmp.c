KMP

利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。


假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置
如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；
如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。
换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。
很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。
此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k > 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。

------------------------------------------------------------------

理解KMP算法的关键在于： 如果我们已经知道了S串中首字符与T串中后面的字符君不相等，那么匹配就可以跳过一部分。
对于在子串中有与首字符相等的字符，也是可以省略一部分不必要的判断位置。


i 不回溯，通过书中的两个的例子，归纳了所有的状况，应该可以用归纳法证明。
而 j 的变化与主串关系不大，关键是T串的结构中是否有重复的问题

           0 ， 当 j = 1 时
next[j] =  Max{ k | 1 < k < j, 且 'p1....k-1' = 'pj-k+1...pj-1'}当此集合不空时
           1， 其他情况

p 代表T 中的字符

/* 通过计算返回子串T的next数组。*/
void get_next(String T, int *next)
{
  int i,j;
  i = 1;
  j = 0;
  next[1] = 0;
  while (i < T[0]) /* 此处T[0]表示串T的长度 */
  {
    if (j == 0 || T[i] == T[j] ) /* T[i]表示后缀的单个字符,  T[j]表示前缀的单个字符*/
    {
      ++i;
      ++j;
      next[i] = j;
    }
    else
      j = next[j]; /* 若字符不相同，则j值回溯*/
  }
}

/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */
/* T非空，1 <= pos <= StrLength(S)。 */
int Index(String S, String T, int pos)
{
  int i = pos;  /* i用于主串S当前位置下标值，若pos不为1， */
                /* 则从pos位置开始匹配*/
  int j = 1;   /* j用于子串T中当前位置下标值 */
  int next[255]; /*定义一next数组 */
  get_next(T, next); /*对串T作分析，得到next的数组 */
  while ( i <= S[0] && j <= T[0] ) /*若i小于S的长度且j小于T的长度时，循环继续 */
  {
    if (j == 0 || S[i] == T[j])  /* 两字母相等则继续，与朴算算法增加了 j = 0 判断 */
    {
      ++i;
      ++j;
    }
    else  /* 指针后退重新开始匹配 */
    {
      j = next[j];  /*j 返回合适的位置，i值不变 */
    }
  }
  if (j > T[0])
    return i - T[0];
  else
    return 0;
}
