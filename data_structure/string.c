暴力匹配算法

注意书里面都是把串的首位当做1来看待.
i <= n - m + 1 是因为我们要找的本身就有T的长度，那么当S的长度小于T，就没必要再比了。

/* T为非空串。若主串S中第pos个字符之后存在与T相等的字串， */
/* 则返回第一个这样的子串在S中的位置，否则返回0 */
int Index(String S, String T, int pos){
  int n,m,i;
  String sub;
  if (pos > 0) {
    n = StrLength(S); /* 得到主串S的长度 */
    m = StrLength(T); /* 得到子串T的长度 */
    i = pos;
    while ( i <= n-m+1) {
      SubString(sub, S, i, m); /* 取主串第i个位置 */
                               /* 长度与T相等子串给sub */
      if (StrCompare(sub, T) != 0)  /* 如果两串不相等 */
        ++i;
      else:         /*如果两串相等*/
        return i;   /*则返回i值*/
    }
  }
  return 0; /*若无子串与T相等，返回0 */
}


或者看这里：

假设现在我们面临这样一个问题：有一个文本串S，和一个模式串P，现在要查找P在S中的位置，怎么查找呢？

如果用暴力匹配的思路，并假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置，则有：

- 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++，继续匹配下一个字符；
- 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。

这里的 i = i - (j - 1) 我们可以理解就把它退回 j - 1步，或者直接理解成 i = i - j + 1， 退回j步，但是是不匹配的，我们就从下一位开始。然后j置为0。
其实我有点不理解为什么不用 i++, j++ 这种简单易懂的|||
